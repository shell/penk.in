<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails plugin | Httpster: Vladimir Penkin]]></title>
  <link href="http://httpster.in/blog/categories/rails-plugin/atom.xml" rel="self"/>
  <link href="http://httpster.in/"/>
  <updated>2013-03-19T12:14:03-05:00</updated>
  <id>http://httpster.in/</id>
  <author>
    <name><![CDATA[Vladimir Penkin]]></name>
    <email><![CDATA[penkinv@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[rails3_before_render plugin]]></title>
    <link href="http://httpster.in/blog/2011/03/11/rails3_before_render-plugin/"/>
    <updated>2011-03-11T14:53:00-05:00</updated>
    <id>http://httpster.in/blog/2011/03/11/rails3_before_render-plugin</id>
    <content type="html"><![CDATA[<p>  I've just released small plugin <a href="https://github.com/shell/rails3_before_render">rails3_before_render</a>. It adds a hook like <code>before_filter</code> to your controllers that gets executed between when your action is completed and the template is rendered.  It can really DRY up loading some data.</p>

<p>  Please be carefull using that. Regular <code>before/after/around</code> filters is enough for <strong>most</strong> of the tasks that you can imagine. If not you always call method directly, that will increase readability of your code. Use <code>before_render</code> in exceptional cases.</p>

<p>  <a href="http://blog.davidchelimsky.net/wp-content/uploads/2010/11/duplication.pdf">Here</a> is good presentation by David Chelimsky about code duplication and DRY concept.</p>

<h2>Use case</h2>

<p>  Mostly I've needed that plugin for my <code>mugen</code> gem.
``` ruby
class Mygengo::JobsController &lt; Mygengo::MygengoController
  . . .
  def show</p>

<pre><code>@job = Mugen::Job.find(params[:id])
@preview = Mugen::Job.preview(@job['job_id'])
@comments = Mugen::Job.comments(@job['job_id'])
</code></pre>

<p>  . . .
end
```</p>

<p>  There is error check after each api request that populate <code>Mugen.errors</code> variable with messages. Every action of controller after all requests has been sent need to check that variable and populate flash messages with that. Without having plugin I used wrapper function like this:
``` ruby</p>

<h1>mygengo_controller.rb</h1>

<p>def mygengo_requests
  yield
  parse_errrors
end</p>

<h1>jobs_controller</h1>

<p>mygengo_requests do
  @job = Mugen::Job.find(params[:id])
  @preview = Mugen::Job.preview(@job['job_id'])
  @comments = Mugen::Job.comments(@job['job_id'])
end
```</p>

<!-- more -->


<p>  After 5-th action code duplication seems unreasonable. Regular filters like <code>before_filter</code> and <code>after_filter</code> didn't fit here. Errors parsing clearly needs to be executed right before rendering.</p>

<p><code>ruby
class Mygengo::MygengoController &lt; ApplicationController
  before_render :parse_errrors
  . . .
</code></p>

<p>  With that I could remove <code>mygengo_request</code> method along with wrapping each action in controller.</p>

<h2>before_render</h2>

<p>  Before writing this plugin I have found <a href="https://github.com/xtoddx/before_render">before_render</a> plugin by Todd Willey. Sadly it worked for rails 2.x only. Rails 3 brought us completely new architecture of ActionPack and as I have found even ActiveSupport had major changes. Callbacks module is now more efficient that is was before.</p>

<p>  New <code>ActiveSupport::Callbacks</code> methods were used, in analogy with ActionDispatch. That allowed me to escape reimplementing callback filter chains.</p>
]]></content>
  </entry>
  
</feed>
